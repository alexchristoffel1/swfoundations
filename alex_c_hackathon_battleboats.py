# -*- coding: utf-8 -*-
"""Alex C Hackathon_Battleboats.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NVT3C1wokWbvK6Dg8fh-jWU2fUCiFhIz

# Software Developer Foundations Hackathon Problem: Battleboats

Let's practice our Python Basics by creating a simple game where you play against your Computer!

We'll be taking our own spin on the classic game **battle ships**, where each player will have three different "boats" on the opposing player's board that they need to "sink". 

If you've never played the game before, [click here](https://www.youtube.com/watch?v=RY4nAyRgkLo&ab_channel=wikiHow) for a short video that explains how the game is played. 

However, we're going to make a simpler version of this game, that uses boats that are only one tile large. In other words, each boat will **only occupy a single space**, instead of the traditional ruleset where a boat may occupy many spaces in a row.

As I'm sure you can guess, this will be a **complex problem** to solve. When faced with complex problems, the solution is to break them down into smaller parts, and tackle them individually, which is exactly what we're going to do.

## Reminder about Colab Projects

Remember that Google Colab has a Python environment constantly running in the background. So, unlike traditional environments like VS Code, creating a variable in one code cell will allow it to be used in other code cells.

This allows us to break our game's logic up into parts for the sake of _practice_, but ultimately we'll be combining what we've done in individual cells into a **final code cell** that will contain the whole game.

# 1. Setting up the Boards

Before we talk Python, let's talk Battle Ships. What is the _purpose_ of the board - in other words, what do we _use it for_?

For the sake of our game, the board's purpose is to tell us **whether or not a boat is present at a given set of coordinates**. In other words, we care about whether an item (the coordinates) _exists_ within the board or not.

You have two options for a data structure to use for this problem. The one you're likely more comfortable with is a **list**, and if you'd like to use a list, that will work just fine.

It's worth noting that the other option is a bit more appropriate for this situation, but it was a footnote during our discussions, so we haven't really gotten our hands dirty with it yet. The data structure in question is known as a **set**, which is like a list that only cares about whether or not an item is the set or not.

Either of these data structures work, so use your favorite for the following steps.

### Testing the Waters

_(Concepts used: Lists, Sets, Sequences)_

So now that we know _why_ we need boards, and we've talked about _what_ data structures we could use to implement them, it's time to talk about the remaining pieces.

* **Do we need to create _actual_ boats?**
No, we don't care about the boats at all for this problem. We only care about _where_ the boats are, which means we only need to store their _location_.
* **How will we store where boats are located?**
The location of boats on the boards will depend on the player. The Human player will input where they'd like those boats to go. The Computer player will randomly place their boats.
* **How will we tell if we hit a ship or not?**
When a player attempts to attack their opponent's board, we can use the `in` keyword to determine if the target location has a ship or not. This is because our list/set will have three coordinates in it that represent a boat being present at that location, and if the `in` keyword returns `True` for that position, we know we hit a boat.
* **What happens when a boat sinks?**
When you hit an opponent boat, they should have that position **removed** from their board.
* **How do you know when a player has lost?**
This is pretty easy: when their board has no more items! That means we sunk each position that contains a boat. Use the `len()` function to achieve this functionality.

---

It's time to actually test out what we want to create.

Let's make a practice cell that does the following:

* Creates an empty board
* Hard-codes a single position into the board
 * This position should be a **Tuple**, where the first value is the X position and the second value is the Y position.
 * Must be "within bounds". The board is **4x4**, and it's up to you if you want it to be one-based or zero-based.
* Print the board's data structure

*HINT: If you want to add an extra challenge and use a set instead of a list, [check this](https://www.w3schools.com/python/python_sets.asp) page out.*
"""

# Create a board
BoardA = {"A1", "A2", "A3", "A4", "B1","B2","B3","B4","C1","C2","C3","C4","D1","D2","D3","D4"}

# Add a boat's location to the board (Hard-Coded for Practice!)
HumanBoat
# Print the board

x = ["A", "B", "C", "D"]
y = ["1", "2", "3", "4"]
print(x[0] + y[0],x[0] + y[1], x[0] + y[2], x[0] + y[3]) 
print(x[1] + y[0],x[1] + y[1], x[1] + y[2], x[1] + y[3])
print(x[2] + y[2],x[1] + y[2], x[1] + y[2], x[2] + y[3])
print(x[3] + y[2],x[3] + y[2], x[3] + y[2], x[3] + y[3])

"""## Setting up Ships

_(Concepts used: Creating Functions, `input()`, Tuples, String Functions)_

Now that we understand generally how a board should be setup, let's create a self-contained code cell with the functionality needed for the player to set up their boats.

We know that each player gets **three** boats, and that each boat takes up a **single** cell on the board.

So, essentially we're asking our players to input an X and Y value that represents a position on the board.

If this were "week 1" all over again, we'd simply call `input()` twice, first time asking for an X value and the second time asking for a Y value. But we've learned a lot of very powerful tricks since then, so let's try and do this a bit more elegantly.

---

Since getting a position from the user is going to take a few lines of code, let's start by creating a **function** that will prompt the user for a position and return the appropriate position as a **tuple**.

To make it easier for the user to enter coordinates, let's prompt the user to enter them in the following format:

```
X,Y
```

Where "X" is the value for the X Coordinate, and "Y" is the value for the Y Coordinate.

Once we've created our function in the code cell below, we'll test it with the driver cell provided.

* **How would we parse that input for two different values?** You may remember our good friend `split()`, which allows us to break a single string into a sequence of "parts", based on a _delimiter_. We'll be using that to separate the X from the Y value.
* **What if the value is out of bounds?**
We'll handle that _outside_ of the function, for simplicity's sake. Don't worry about that yet.
* **What happens if a user enters something in the wrong format?** We're in the middle of a Hackathon today with many different assignments to do, so don't worry about that! For this assignment, let's just _assume_ the user always enters values in the appropriate format.
"""

boatOne = (A,3)
boatOne = tuple(boatOne)
for space in board:
  if space == boatOne:  
    space = "Boat One"
# Print the board
print(board)

### Write your Player Input function here: ###
def getPlayerPos():
  # Prompt the user for a position string
  boatLocation = input("Enter a location? separate x axis and y axis by : ")
  # Get the X and Y Value separately
  x, y = boatLocation.split(":")
  # Return the position as a tuple
#  return (parts[0], parts[1])
  return (x,y)
myBoard = []
for boatPlacement in range(3):
  myBoard.append(getPlayerPos())
print(myBoard)

### Run this cell to test your input function!! ###
pos1 = getPlayerPos()
print("Should display in the following format: (X, Y)")
print(pos1)
print(f"X Value: {pos1[0]}, Y Value: {pos1[1]}")

"""_(Concepts used: Loops, Using Functions)_

Now that we've created a function that gets **one** position from the user, let's use a loop and a list/set to store each position into the board!

The tricky part is that, even though we don't need to validate the input for format, we _do_ need to make sure the position is within bounds on the board, and not colliding with another ship. So, we're going to need two loops.

The outer loop should run for each ship we want to place on the board. The inner loop should re-run only if the ship couldn't be placed at a certain position.

There are only two reasons to repeat the inner loop:

* There is ALREADY a ship at the position the user typed in (can't stack them up)
* The X or Y value exceeds the board's size in EITHER direction
"""

boatplacement = 3
while boatplacement != 3:
  getPlayerPos()
  print()

def createPlayerBoard(numShips):  # Create a new board
  myBoard = []
  row = ["A", "B", "C", "D"]
  # Run a loop to store 3 ships
  for boatPlacement in range(numShips):
    # Begin a "validation loop" that only re-runs if the input is out of bounds/duplicate
    valid = False
    while valid == False:
      # Grab a position from the user
      position = getPlayerPos()
      if position[1] > 4 or position[1] < 0 or (position[0] not in row) or position in myBoard:
        print("Not Valid, try again")
      else:
        myBoard.append(position)
        valid = True      
      
    ## By this point in your code, the position the user entered has been validated ##
    # Add the position to the board
  # Print the board for test purposes
  return (myBoard)

"""## Rise of the Machine

_(Concepts used: Modules, `random`, Loops)_

We're going to setup the fun part now - a randomized computer player to challenge the player!

Having the computer's ships be randomized keeps the game interesting, as you never know who you're going to go up against.

To do this, we're going to need to create a _different_ function than we did earlier that returns a position for a computer player instead of a human player.

This function will "generate" a random position. What should be very obvious is that, unlike the previous function, this one is going to need **two arguments**: the width and height of the board. This prevents it from generating spaces that are "out of bounds".

Just like how we generated human positions, don't worry about duplicate checking inside the function. We'll handle it outside the function when we call it.

Write your function in the code cell below, then test it with the driver below that.
"""

### INCLUDE THE RANDOM MODULE BELOW THIS LINE ###
import random
import string 
### Write your Computer Input function here: ###
def getComputerPos(width, height):
  y = random.randint(1,width)
  x = random.choice("ABCD")
  return (x,y)

### Run this cell to test your function!! ###
pos2 = getComputerPos(4, 4)
print("Should display in the following format: (X, Y)")
print(pos2)
print(f"X Value: {pos2[0]}, Y Value: {pos2[1]}")

def createComputerBoard(numShips):
  compBoard = []
  for i in range(numShips):
    pos = getComputerPos(4, 4)
    repeat = False
    while not repeat:
      if pos not in compBoard:
        compBoard.append(pos)
        repeat = True
      else:  
        pos = getComputerPos(4, 4)
  return compBoard

computerBoard=createComputerBoard(3)
print(computerBoard)

"""_(Concepts used: Loops, Using Functions)_

Now let's tie it all together, and create the "setup" part of our game. This is where we'll generate **both** the player and computer player's ships. 

The order in which you generate them does _not_ matter. They should each have their own board, after all.

Unlike when we setup the player's board, the pseudo-code for setting up the computer's board will **not** be provided. It's virtually the same as how you setup a player, so you should be able to infer the solution by looking at how you solved the player's setup.

Begin by copying and pasting the code you wrote in the _last code cell_ from the section "Setting Up Ships" in the code cell below. Then add the code needed to setup the computer player.

Finally, print **both boards**.
"""

### START BY COPY/PASTING YOUR CODE FROM THE LAST CELL OF "SETTING UP SHIPS" ###


playerBoard = createPlayerBoard(3)
print(playerBoard)
computerBoard=createComputerBoard(3)
print(computerBoard)

"""# Playing the Game

_(Concepts used: Loops, Control Flow)_

Congratulations, you've gotten to the halfway point! Now that our boards are setup, we just need to start playing the game itself.

A single "round" of battle boats involves each player taking one turn. In other words, a round consists of both the player and computer attacking the other.

Then we repeat _until_ one player loses all of their ships.

As we discussed in the Program Design lecture, abstract problems like "implementing the gameplay loop of battle boats" is best tackled when we can break it down into smaller parts.

So, let's look at a "bird's eye view" of what this game consists of:

* Determining what space to attack
* Sinking Ships
* Switching Turns
* Determining when the game is over

We know that all of this needs to be wrapped up in a "gameplay loop". The type of loop we need should be clear from the "key word" used earlier: _until_.

That's right, we need a `while` loop, because we _don't know **when**_ the game is over or not. It's over if a certain condition is met, and we have no idea _when_ it will be met.

## Loose Lips...

_(Concepts used: Creating Functions, Booleans)_

So now that we've talked about what we need to accomplish in this section, let's start by picking the step that is "self-contained" compared to the rest of the problem: Sinking the Ship.

Sinking the Ship is an _action_, and that word should trigger you to think of **functions**. We want to _do_ something when a ship should be sunk: remove it's position from the appropriate board.

And it doesn't matter whether the human or computer player is sinking a ship, right? We just want to take in a board and a position, and remove it.

But we also need to make sure that there is a ship at that position. Many functions in Python and other languages will return a _boolean_ when executed to show whether they **successfully completed or not**, and our function will be no different.

If a ship exists at this position, we're going to remove it from the board and return `True`. Otherwise, we're going to do nothing and return `False`.

This way we can let the game itself determine what to do in the event of a success/fail, whether that means displaying a message or otherwise. Remember that we generally want functions to be self-contained, and not worry about the "bigger picture" like who is winning or losing, just do their job without thinking about anything else.

---

Write your function in the cell below, and test it with the driver underneath.
"""

### Write your Ship Sinking function here: ###
def trySinkShip(pos, board):
  
  # Is there a boat at this position in the board?

    # If there is, remove it from the board

    # Then return "True" to let the game know we hit a boat
  
  # Otherwise, return "False" to let the game know we did NOT hit a boat

### Run this code cell to test your function! ###

fakeBoard = [(1,1)]

# Test a failure:
failResult = trySinkShip((2,2), fakeBoard)
print("Testing a Failure. Result should be False.")
print(f" Result: {failResult}")
print("Board should have one item in it.")
print(f" Board Length: {len(fakeBoard)}")

# Test a success:
goodResult = trySinkShip((1,1), fakeBoard)
print("Testing a Success. Result should be True.")
print(f" Result: {goodResult}")
print("Board should have no items in it.")
print(f" Board Length: {len(fakeBoard)}")

"""## Taking Turns

_(Concepts used: Loops, Using Functions, Control Flow, Program Design)_

Now that we've created the ability to sink a ship or not, we need to start writing the actual game loop.

At this point, there's not much left to do other than tie it all up together, so we'll break through the last three steps we outlined together.

* **How do we "Determining which space to attack"?** Technically, we already did this part! You can re-use the functions we created to setup the board, `getPlayerPos()` and `getComputerPos()`.
* **How do we handle "Determining when the game is over"?** Well, without using Python, how do we know when a game of battle boats is over? We simply play until someone runs out of ships. So, the game loop should run until either board runs out of ships!
* **How do we handle "Turn Taking"?** We know that a each turn follows the same steps - determining an attack to use, performing the attack, seeing if we hit something or not, then determining if we lost. So, each iteration of the loop should be a single turn. At the beginning, we can determine whose turn it is, to make slight adjustments in how decisions are handled.
 * There are a number of different implementation options for this step: using a boolean that toggles it's value, taking the mod 2 of the current turn number, etc. Use what ever makes the mose sense to you.
* **I have two different boards - one for the computer player and one for the human player. Do I need one million `if` statements in my code?** No! You can create a variable called "activePlayerBoard" and "opponentBoard", and set them equal to the appropriate board (human vs computer) during the "Determine whose turn it is" step of pseudo-code located in the code cell below. Then, for the rest of your "turn logic", you can just refer to these new "alias variables" (not to be confused with an alias for a module).
In other words, you can do this:

```
if(humanTurn):
  attackingBoard = compBoard
  defendingBoard = humanBoard
else:
  attackingBoard = humanBoard
  defendingBoard = compBoard

...

result = trySinkShip(pos, attackingBoard)
```
"""

### REPLACE THIS LINE OF CODE WITH THE "BOARD SETUP" YOU DID AT THE END OF THE "SETTING UP THE BOARDS" SECTION

# Begin looping until one player's board is empty

  # Determine whose turn it is

  # Determine which space to attack

  # Try to attack that space and use the result to see if...

    # ...We hit a ship! Display a message that the ship at this position has sunk

    # Display a message showing how many ships are left
  
  # ... We didn't hit a ship.

    # Display a message that we didn't hit anything.

### At this point, the game loop ended ###

# Display the winner of the game (the player with more than zero boats left)

"""# CHALLENGE: A Harder Opponent

Right now, you've probably noticed it's very hard for the CPU player to win. That's because there's _nothing_ stopping the CPU from picking the same space more than once.

Human players will remember whether or not they selected a space already (and if they forget, they can always look at the console log!) so they will only ever have to take as many turns as there are spaces on the board. Inevitably, sometime before that amount, they will will the game.

So can we give the computer this functionality as well? **Yes**.

For a game like this, where the boats are only one tile large, the _optimal strategy_ is to randomly pick a _new_ tile you _haven't guessed before_. You can't really get better than that.

So, how could we give the CPU player _memory_? Think back to how we placed the CPU's boats. We determined if something was in a list, and if it _wasn't_, we added it to the list.

We could do a similar thing for the CPU. We could have a separate list that works as "memory", and then see if we "remember" guessing that tile or not.

The rest is up to you - this is a challenge after all!
"""